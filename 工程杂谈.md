
author:young<br>
python/c++/计算机基础/大数据/数据结构基础<br>

## Python
【1.】python里tuple和list区别<br>
https://www.cnblogs.com/zhaolide/p/10026417.html<br>
相同点：<br>
list和tuple都是可迭代对象中的容器序列，能存放不同类型的数据，并且存的是它们所包含的任意类型的对象的引用。<br>
不同点：<br>
a.)list中的元素可以改变，也可以对list进行增删操作。tuple是不可变的列表（list）。一旦定义后，tuple中的元素不能再被改变，也不能增删。<br>
b.)原子性的 tuple 对象还可作为字典的键，列表不能做字典的关键字。<br>
c.)同样大小的数据，tuple 占用的内存空间更少。<br>


【2.】python dict 怎么实现的<br>
https://zhuanlan.zhihu.com/p/159483848<br>
a.)dict对象在python中属于mapping对象，一种标准映射类型。mapping容器对象：支持任意键查找，并实现了 Mapping或MutableMapping抽象基类中所规定方法。<br>
b.)在3.7 版本之后，字典类型将会**保留插入的顺序，删除并再次添加的键将被插入到末尾**。在之前的版本中则不保证顺序，不过可以使用OrderedDict。<br>
c.)字典和集合主要**基于散列表**的方法，如果程序包含磁盘IO，则一个存储在内存中的 任意大小的字典或集合的 查询操作所需要的时间 可以忽略不记。由于字典使用了散列表，且保证了散列表的稀疏性，**字典本身占用的空间较大**。<br>
散列表本身是一个稀疏的数组，在dict中，每一个键值对都占用一个表元，表元大小一致，内部包含的是对键值的分别引用。表元的大小一致决定了散列表本身能够通过偏移量来读取某个表元。Python会设法保证大概1/3的表元是空的，这样设计来保证散列表的冲突概率降低。即使有数百万个元素的dict，整个搜索平均的冲突次数可能仅有1-2次。当这个阈值到达时，原来的散列表会被复制到更大的空间里。这个复制的过程不保证顺序，所以当使用视图迭代时，可能会因为插入操作而改变顺序，导致部分值无法被遍历或者runtime error。<br>


【3.】python的动态数组是如何实现的<br>
https://baijiahao.baidu.com/s?id=1612827637125222513&wfr=spider&for=pc<br>
Python中的array类似于列表list，如都**可以动态增删元素**，但**array中元素类型必须完全一样**。另外，由于list中每个元素同时存储了其地址即指针（用以标记每个元素的数据类型）和实际的数据，所以，在存储及操作效率上，array又远远高于列表。在数组的定义中，**数组元素的类型通过一个字符typecode参数指定**。<br>


【4.】python的GIL<br>
https://www.cnblogs.com/ArsenalfanInECNU/p/9968621.html<br>
GIL的全称是 Global Interpreter Lock，全局解释器锁，Python的执行依赖于解释。<br>
GIL的优点：可以保证我们在多线程编程时，无需考虑多线程之间数据完整性和状态同步的问题。<br>
GIL的缺点：多线程程序执行起来是“并发”，而不是“并行”。因此执行效率会很低，会不如单线程的执行效率。<br>
Python最初的设计理念在于，为了解决**多线程之间数据完整性和状态同步**的问题，设计为**在任意时刻只有一个线程 在解释器中运行**。<br>
而当执行多线程程序时，由GIL来控制 同一时刻只有一个线程能够运行(为了Python解释器中原子操作的线程安全)。<br>
即Python中的多线程是表面多线程，也可以理解为fake多线程，不是真正的多线程。多个线程的代码，轮流被解释器执行，只不过切换的很频繁很快，给人一种多线程“同时”在执行的错觉。聊的学术化一点，其实就是“并发”。<br>
在多线程环境中，当各线程不共享数据的时候，那么一定是线程安全的。<br>


【5.】python里的多线程，怎么让它占满核呢？<br>
https://www.jianshu.com/p/94a1caf21720<br>
在python中，使用threading多线程库编程并不会使用计算机的多cpu核，仍然是使用的单核进行计算的，不会加快计算速度。如果在python开发工作中必须使用多cpu核提高计算速度可以**使用multiprocessing库**，它的使用方式和threading方式非常类似。<br>
为了利用多核，Python开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。 于是有了GIL这把超级大锁，越来越多的代码库开发者接受了这种特性。GIL帮助我们保持不同线程之间的数据一致性问题。<br>
multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。<br>


## 计算机基础
##### 原子操作：不会因为进程并发或者线程并发而导致被中断的操作。原子操作的特点就是要么一次全部执行，要么全不执行。不存在执行了一半而被中断的情况。当对全局资源存在写操作时，如果不能保证写入过程的原子性，会出现脏读脏写的情况。
##### 并发：不同的代码块交替执行；并行：不同的代码块同时执行。


【1.】线程与进程：锁/悲观锁乐观锁<br>
https://www.cnblogs.com/renhui/p/9755789.html<br>
悲观锁和乐观锁是java里的概念。<br>
总是假设最坏的情况，每次去拿数据的时候都认为**别人会修改**，所以每次在**拿数据的时候都会上锁**，这样别人想拿这个数据就会**阻塞**直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。<br>
总是假设最好的情况，每次去拿数据的时候都认为**别人不会修改**，所以不会上锁，但是在更新的时候 会判断一下 在此期间别人有没有去更新这个数据。乐观锁适用于**多读的应用类型**，这样可以提高吞吐量。<br>


【2.】进程线程的区别？进程和线程相比有什么好处？<br>
https://zhuanlan.zhihu.com/p/60558136<br>
进程是系统资源分配的最小单位(餐桌)，线程是程序执行的最小单位(吃饭的人)。<br>
进程和线程的主要差别在于它们是**操作系统不同的资源管理方式**。**进程有独立的地址空间**，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线**程只是一个进程中的不同执行路径**。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。<br>
    进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。<br>
    线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。<br>
    计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。<br>
    进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。<br>
    线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。<br>


【3.】用户态和内核态<br>
https://blog.csdn.net/IT_10/article/details/93911483<br>
Linux操作系统的体系架构分为用户态和内核态（用户空间和内核空间），这种分层的架构极大地提高了资源管理的可扩展性和灵活性，而且方便用户对资源的调用和集中式的管理，带来一定的安全性。<br>
内核是操作系统的核心，本质上是一种软件—控制计算机的硬件资源，并提供上层应用程序运行的环境，有权访问受保护的内存空间和底层硬件设备。<br>
用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、IO资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。<br>


【4.】堆空间、栈空间了解吗？<br>
https://www.cnblogs.com/Vancamel/p/11313883.html<br>
栈区（stack）：**由编译器自动分配释放，存放函数的参数值，局部变量的值等**，其操作方式类似于数据结构的栈。<br>
堆区（heap）：一般是由程序员分配释放，若程序员不释放的话，程序结束时可能由OS回收。C中用函数malloc分配空间，用free释放，C++用new分配，用delete释放。值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。<br>


【5.】如何判断机器是大端模式还是小端模式<br>
https://www.jianshu.com/p/cb15a96fee62<br>
大端模式：高位字节在前，低位字节在后。把仅有的数字位先存放到高位字节处。<br>


## C++
【1.】c++面向对象介绍下<br>
面向对象是一种编程范式，具有抽象、封装、继承、多态等属性。<br>
抽象：对同类共同属性和行为概括，形成类。<br>
封装：将抽象出来的数据、代码封装在一起，形成类。增强安全性。<br>  
继承：在已有的类基础上（即继承已有的），进行扩展形成新的类。<br>
多态：同一名称，不同的功能实现方式。为减少程序中标识符的个数。<br>


【2.】c++的虚函数和虚继承<br>
https://blog.csdn.net/cymy001/article/details/78671807<br>



【3.】c++的常量引用传参出现的问题<br>
https://www.cnblogs.com/hailexuexi/archive/2012/02/08/2342232.html<br>
引用通常情况下是以指针的形式实现的，所以通过引用传递通常意味着实际上是在传递一个指针。只有内建数据类型、 STL 迭代器和函数对象类型适用于传值方式。对于所有其它的类型，尽量使用引用常量传参。<br>

【4.】c++说一下有序map和无序map的区别以及底层实现？<br>
map内部是红黑树，在插入元素时会自动排序，而无序容器unordered_map内部是散列表，通过哈希而不是排序来快速操作元素，使得效率更高。当你不需要排序时选择unordered_map的效率更高，unordered_map的插入速度明显优于map。<br>


【5.】c++里static<br>
https://blog.csdn.net/cymy001/article/details/78671733<br>
静态变量初始化0，只在声明作用域范围内可见(局部-函数，全局-文件)。<br>
在类中，静态成员可以实现多个对象之间的数据共享。对静态成员的引用 使用类名。在静态成员函数的实现中，不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。<br>


【6.】new 和malloc有什么区别<br>
https://blog.csdn.net/nyist_zxp/article/details/80810742(细节比较多)<br>
C语言提供了malloc和free两个系统函数，需要头文件支持，完成对堆内存的申请和释放。<br>
C++提供了两个关键字new和delete，需要编译器支持，效率高于malloc和free。配对使用，避免内存泄漏和多重释放。new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理。


【7.】你知道智能指针底层怎么实现的吗？<br>
https://zhuanlan.zhihu.com/p/111810376<br>
shared_ptr 的原理是，在内部维护了一个**对象的引用计数**，但引用计数归零，即最后一个指向对象的 shared_ptr 被销毁时，将指向的对象也释放掉。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。<br>


## 大数据
【1.】2.5亿个整数找不重复的整数，内存无法一下存下这2.5亿个数，怎么做。<br>
http://www.100mian.com/mianshi/python/4789.html<br>
1G=2^10M，1M=2^10K，1K=2^10byte，1byte=8bit => 1G=8·2^30 bit=8·10^9 bit<br>
数据可能存在的方式只有三种：没出现过，出现了一次，出现了很多次。所以我们用2bit表示这三种状态。<br>
2.5 ·（10^8）· 2）/ 8 · (10^9) = 0.06G<br>



## 数据结构基础
【1.】说下红黑树，怎么插入的？简单一点的，比如AVL树呢？<br>
https://www.yidianphp.com/archives/820<br>



【2.】什么是平衡二叉树？什么是二叉树？平衡二叉树的应用都有哪些？<br>
二叉树是一种最基本的树形数据结构，用来方便存储基本数据 并且能有很高的的查询效率。<br>
平衡二叉树(AVL)是 任意节点的左右子树的深度 相差不超过１，可以更高效得获取出树节点的数据。<br>
有种特殊的平衡二叉树红黑树，查找、插入、删除的时间复杂度最坏为O(log n)。C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。还有哈夫曼树编码方面的应用。B-Tree，B+-Tree在文件系统中的应用。<br>


【3.】哈希表了解吗？有哪些解决冲突方法？<br>
https://blog.csdn.net/weixin_41910694/article/details/96359964<br>








